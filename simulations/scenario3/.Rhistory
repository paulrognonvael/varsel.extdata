if(length(sel.ebic)!=0){
df[df$method=='EBIC','sel.model'] <- sel.ebic
}else{
print(sel.ebic)
}
if(length(sel.lasso)!=0){
df[df$method=='lasso','sel.model'] <- sel.lasso
}else{
print(sel.lasso)
}
if(length(sel.baseline1)!=0){
df[df$method=='baseline1','sel.model'] <- sel.baseline1
}else{
print(sel.baseline1)
}
if(length(sel.baseline2)!=0){
df[df$method=='baseline2','sel.model'] <- sel.baseline2
}else{
print(sel.baseline2)
}
if(length(sel.method1.1)!=0){
df[df$method=='method1.1','sel.model'] <- sel.method1.1
}else{
print(sel.method1.1)
}
if(length(sel.method1.2)!=0){
df[df$method=='method1.2','sel.model'] <- sel.method1.2
}else{
print(sel.method1.2)
}
if(length(sel.method2)!=0){
df[df$method=='method2','sel.model'] <- sel.method2
}else{
print(sel.method2)
}
gc()
return(df)
}
##### Scenario ######
nb.inactive2 <-function(n){
return(n/2)
}
nb.inactive3 <-function(n){
return(n)
}
nb.inactive.tot<-function(n,nb.inactive.b0=nb.inactive3,nb.inactive.b1=nb.inactive2){
nb.inactive.b0(n)+nb.inactive.b1(n)
}
nb.active<- function(n){
return(exp(sqrt(log(n))))
}
# Dimension
bmin <- function(n,fun.nb.inactive){
bmin <- sqrt(8*log(fun.nb.inactive(n=n))/n*(2*log(log(n))/3))
#bmin <- 3
return(bmin)
}
# Generate design matrix
# n <- 700
# p <- 2000
# set.seed(27)
# cov <- 0.5
# Sigma <- matrix(rep(cov,p*p),ncol=p)
# diag(Sigma) <- rep(1,p)
# mu <- rep(0,p)
# X <- rmvnorm(n,mu,Sigma)
# X.design <- X %*% diag(1/sqrt(diag(t(X) %*% X)/n))
# write.csv(X.design,"X.designp2000n700.corr.csv",row.names = FALSE)
#X <- as.matrix(read.csv("X.designp10000.corr.csv"))
X <- as.matrix(read.csv("X.designp2000n700.corr.csv"))
# Generate errors
# epsilon <- rnorm(100*100,0,1)
# write.csv(epsilon,"epsilon.csv",row.names = FALSE)
epsilon <- as.matrix(read.csv("epsilon.csv"))
options(error=browser)
###################################################
values <- seq(100,700,100)
iter <- 1
for (n  in values){
niter <- length(values)
betamin <- bmin(n,nb.inactive.tot)
beta_star0 <- c(rep(betamin,round(nb.active(n)/2)), rep(0,nb.inactive3(n)))
beta_star1 <- c(rep(betamin,round(nb.active(n)/2)), rep(0,nb.inactive2(n)))
beta_star <- c(beta_star0, beta_star1)
block0 <- c(1:length(beta_star0))
block1 <- c((length(beta_star0)+1):(length(beta_star0)+length(beta_star1)))
X.design <- X[1:n,1:length(beta_star)]
# Simulation
m <- 100 #number of simulations
y.df <- replicate(m,(X.design%*%(beta_star))[,1])+epsilon[1:(n*m),1]
t0 <- Sys.time()
sim.result <- future_apply(y.df,2,selection.comp,X.design=X.design, block0=block0, block1=block1, beta_star= beta_star, future.seed=TRUE)
sim.result.df <- bind_rows(sim.result)
# sim.result.df <- data.frame()
# for(i in 1:100){
#   res<- selection.comp(y.df[,i],X.design=X.design, block0=block0, block1=block1, beta_star= beta_star)
#   sim.result.df <- bind_rows(sim.result.df,res)
# }
sim.result.df$betamin <- betamin
sim.result.df['recovery']<-  sim.result.df$sel.model==paste(as.character(which(beta_star!=0)),collapse=",")
sel.list <- lapply(sim.result.df$sel.model, model.char2vec)
sim.result.df['nb.tI.b0'] <- sapply(sel.list, nb.error, true.beta=beta_star, type='I', block=block0)
sim.result.df['nb.tI.b1'] <- sapply(sel.list, nb.error, true.beta=beta_star, type='I', block=block1)
sim.result.df['nb.tII.b0'] <- sapply(sel.list, nb.error, true.beta=beta_star, type='II', block=block0)
sim.result.df['nb.tII.b1'] <- sapply(sel.list, nb.error, true.beta=beta_star, type='II', block=block1)
sim.result.df['est.size'] <- sapply(sel.list,length)
write.csv(sim.result.df,paste0("sim.result.scenario2.n",n,".csv"),row.names = FALSE)
t1 <- Sys.time()
cat('Time iteration',iter,'out of', paste0(niter,':'), round(difftime(t1, t0, units = "mins"),3),'minutes'); cat('\n');
iter <- iter +1
}
700*100
epsilon <- rnorm(700*100,0,1)
write.csv(epsilon,"epsilon.csv",row.names = FALSE)
epsilon <- as.matrix(read.csv("epsilon.csv"))
library(mvtnorm)
library(tidyverse)
library(ggplot2)
library(mombf)
library(stringr)
library(glmnet)
library(future.apply)
# Parallelizing
plan(multicore)
# Helper functions
get.model <- function(glmnet.beta){
return(paste(unname(which(glmnet.beta!=0)),collapse=","))
}
model.char2vec <- function(model.char){
return(as.numeric(strsplit(model.char,",")[[1]]))
}
min.abs.beta <-function(v){
return(min(abs(v[v >0.00001])))
}
nb.error<-function(sel.vect, true.beta, type, block){
truth <- true.beta != 0
sel.model <- rep(FALSE, length(true.beta))
sel.model[sel.vect] <- TRUE
if(type=='I'){
tI <- truth==FALSE & sel.model==TRUE
return(sum(tI[block]))
} else if (type=='II'){
tII <- truth==TRUE & sel.model==FALSE
return(sum(tII[block]))
} else{
stop("Invalid type of error")
}
}
lasso.ebic <- function(y,x,extended=TRUE) {
#Select model in LASSO path with best BIC (using LASSO regression estimates)
#Input
# - y: vector with response variable
# - x: design matrix
#
#Output: list with the following elements
# - coef: LASSO-estimated regression coefficient with lambda set via BIC
# - ypred: predicted y
# - lambda.opt: optimal value of lambda
# - lambda: data.frame with bic and number of selected variables for each value of lambda
require(glmnet)
fit <- glmnet(x=x,y=y,family='gaussian',alpha=1,intercept = FALSE)
pred <- cbind(1,x) %*% rbind(fit$a0,fit$beta)
n <- length(y)
p <- colSums(fit$beta!=0) + 1
if (!extended){
bic <- n * log(colSums((y-pred)^2)/length(y)) + n*(log(2*pi)+1) + log(n)*p
} else {
bic <- n * log(colSums((y-pred)^2)/length(y)) + n*(log(2*pi)+1) + log(n)*p + 2*log(choose(ncol(x),p))
}
sel <- which.min(bic)
beta <- c(fit$a0[sel],fit$beta[,sel]); names(beta)[1]= 'Intercept'
ypred <- pred[,sel]
ans <- list(coef=beta,ypred=ypred,lambda.opt=fit$lambda[sel],lambda=data.frame(lambda=fit$lambda,bic=bic,nvars=p))
return(ans)
}
## Returns exact information criteria for a given model
inf.crit <- function(model, y, X.design, block0, block1, s0.hat, s1.hat, bmin0.hat, bmin1.hat,true.bmin){
beta.hat <- rep(0,ncol(X.design))
k <- 0
k0 <-0
k1 <- 0
n <- length(y)
if (sum(is.na(model))!=length(model)){
model <- model[!is.na(model)]
X.model <- X.design[,model]
beta.hat[model] <- solve(t(X.model)%*%X.model)%*%t(X.model) %*% y
k0 <- sum(beta.hat[block0] !=0)
k1 <- sum(beta.hat[block1] !=0)
k <- sum(beta.hat !=0)
}
s.hat <- s0.hat + s1.hat
s0.hat2 <- min(s0.hat,n^{0.25})
s1.hat2 <- min(s1.hat,n^{0.25})
s.hat2 <- min(s.hat,n^{0.25})
bmin.hat <- min(bmin0.hat,bmin1.hat)
pred <- X.design%*%beta.hat
# "Linearized" EBIC
ic <- 0.5*n*log(sum((y-pred)^2)/n) + k*0.5*log(n) + k*log(ncol(X.design))
# EBIC
ebic <- 0.5*n*log(sum((y-pred)^2)/n) + 0.5*k*log(n) + log(choose(ncol(X.design),k))
# Adaptive baselines
baseline1 <- 0.5*n*log(sum((y-pred)^2)/n) + 0.5*k*log(n) + k*log(ncol(X.design)/s.hat-1)
baseline2 <- 0.5*n*log(sum((y-pred)^2)/n) + 0.5*k*log(n) + k*log(ncol(X.design)-s.hat)
#baseline2 <- 0.5*n*log(sum((y-pred)^2)/n) + 0.5*k*log(n) + k0*log(ncol(X.design[,block0])) + k1*log(ncol(X.design[,block1]))
# method 1
method1.1 <- 0.5*n*log(sum((y-pred)^2)/n) + 0.5*k*log(n) + k0*log(ncol(X.design[,block0])/s0.hat-1) + k1*log(ncol(X.design[,block1])/s1.hat-1)
method1.2 <- 0.5*n*log(sum((y-pred)^2)/n) + 0.5*k*log(n) + k0*log(ncol(X.design[,block0])/s0.hat2-1) + k1*log(ncol(X.design[,block1])/s1.hat2-1)
# method 2
method2 <- 0.5*n*log(sum((y-pred)^2)/n) + 0.5*k*log(n) + k0*log(ncol(X.design[,block0])-s0.hat) + k1*log(ncol(X.design[,block1])-s1.hat)
#oracle <- 0.5*n*log(sum((y-pred)^2)/n) + k*(0.5*true.bmin+log(ncol(X.design)/5-1)/(n*true.bmin))^2*(n/2)
#block.oracle <- 0.5*n*log(sum((y-pred)^2)/n) + k0*(0.5*true.bmin+log(ncol(X.design[,block0])/4-1)/(n*true.bmin))^2*(n/2) + k1*(0.5*3+log(ncol(X.design[,block1])/1-1)/(n*3))^2*(n/2)
models.val <- paste(model, collapse = "," )
return(c(models.val,ic, ebic, baseline1,
baseline2, method1.1, method1.2, method2))
}
## Returns exact information criteria for all models in a given list
compute.infcrit<-function(models, y, X.design, block0, block1, s0.hat, s1.hat, bmin0.hat, bmin1.hat, true.bmin){
infcrit.df<- apply(models,1,inf.crit,y=y,X.design=X.design,
block0=block0, block1=block1, s0.hat=s0.hat, s1.hat=s1.hat,
bmin0.hat = bmin0.hat, bmin1.hat = bmin1.hat, true.bmin = true.bmin)
infcrit.df <-data.frame(t(infcrit.df))
infcrit.df[,-1] <- sapply(infcrit.df[, -1], as.numeric)
colnames(infcrit.df)<-c('model','IC','EBIC','baseline1','baseline2',
'method1.1', 'method1.2', 'method2')
return(infcrit.df)
}
selection.comp <-function(y, X.design, block0, block1, beta_star){
# Extract top IC list
bestIC.res <- mombf::bestIC(y,X.design, penalty= log(nrow(X.design))+2*log(ncol(X.design)),
verbose=FALSE, maxvars= nrow(X.design)
#vmaxvars=nrow(X.design)*0.9,
# deltaini=ini,
)
sel.IC <- bestIC.res$models$modelid[1]
topIC <- distinct(bestIC.res$models)[,1]
# Add models visited by lasso
glmnet.res<- cv.glmnet(X.design,y,intercept = FALSE)
models.glmnet <- data.frame(modelid=apply(glmnet.res$glmnet.fit$beta,2,get.model))
topIC.lasso.list<- distinct(rbind(topIC,models.glmnet))
# Format list of models
max.model.size <- max(sapply(str_split(topIC.lasso.list$modelid, ","),length))
topIC.lasso.fmted <- str_split_fixed(topIC.lasso.list$modelid, ",",max.model.size)
topIC.lasso.fmted[topIC.lasso.fmted == ""] <- NA
class(topIC.lasso.fmted) <- "numeric"
# sanity check can't have models with more than n variables
topIC.lasso.fmted <- topIC.lasso.fmted[,1:min(nrow(X.design)-1,ncol(topIC.lasso.fmted))]
#write.csv(topIC.lasso.fmted, 'topmodels.csv')
# Estimate s, s0.hat, s1.hat
margprob <- bestIC.res$msfit$margpp
s.hat <- sum(margprob,na.rm=TRUE)
margprob0 <- margprob[block0]
margprob1 <- margprob[block1]
s0.hat <- sum(margprob0,na.rm=TRUE)
s1.hat <- sum(margprob1,na.rm=TRUE)
# Cleaning
rm(bestIC.res)
# Estimate bmin0, bmin1
# post.beta <- rnlp(msfit=bestIC.res$msfit, niter=10000)
# post.beta <- post.beta[,-c(1,ncol(X.design)+2)]
# bmin0.hat <- median(apply(post.beta[,block0],1,min.abs.beta))
bmin0.hat <- NA
# bmin1.hat <- median(apply(post.beta[,block1],1,min.abs.beta))
bmin1.hat <- NA
## Sanity checks
truth <- beta_star!=0
truth.char <- paste(as.character(which(beta_star!=0)),collapse=",")
is.true.model.intopIC.res <- rep(truth.char %in% topIC$modelid,8)
is.true.model.intopICplusLASSO.res <- rep(truth.char %in% topIC.lasso.list$modelid,8)
is.s.hat.nan.res <- rep(is.na(sum(margprob)),8)
true.bmin <- min(beta_star[beta_star!=0])
## selected models
inf.crit.df <- compute.infcrit(topIC.lasso.fmted, y, X.design, block0, block1, s0.hat, s1.hat, bmin0.hat, bmin1.hat, true.bmin)
sel.IC <- inf.crit.df[which.min(inf.crit.df$IC),"model"]
sel.ebic <- inf.crit.df[which.min(inf.crit.df$EBIC),"model"]
sel.baseline1 <- inf.crit.df[which.min(inf.crit.df$baseline1),"model"]
sel.baseline2 <- inf.crit.df[which.min(inf.crit.df$baseline2),"model"]
sel.method1.1 <- inf.crit.df[which.min(inf.crit.df$method1.1),"model"]
sel.method1.2 <- inf.crit.df[which.min(inf.crit.df$method1.2),"model"]
sel.method2   <- inf.crit.df[which.min(inf.crit.df$method2),"model"]
# sel.oracle <- inf.crit.df[which.min(inf.crit.df$oracle),"model"]
# sel.block.oracle <- inf.crit.df[which.min(inf.crit.df$block.oracle),"model"]
### LASSO + EBIC
res.lassoebic <- lasso.ebic(y,X.design)
sel.lasso <- get.model(res.lassoebic$coef)
## formating results
method.vec <- c(
"IC",
"EBIC",
"lasso",
"baseline1",
"baseline2",
"method1.1",
"method1.2",
"method2"
# "oracle",
# "block oracle"
)
sel.model.res <-c(
sel.IC,
sel.ebic,
sel.lasso,
sel.baseline1,
sel.baseline2,
sel.method1.1,
sel.method1.2,
sel.method2
# sel.oracle,
# sel.block.oracle
)
s.hat0.res <- rep(s.hat, 8)
s0.hat0.res <- rep(s0.hat, 8)
s1.hat0.res <- rep(s1.hat, 8)
betamin.res <- rep(min(beta_star), 8)
bmin0.hat0.res <- rep(bmin0.hat, 8)
bmin1.hat0.res <- rep(bmin1.hat, 8)
#cat('Update time: '); print(Sys.time()); cat('\n');
df <- data.frame(method = method.vec, sel.model=rep(NA,8),
is.true.model.intopIC = is.true.model.intopIC.res,
is.true.model.intopICpluslasso = is.true.model.intopICplusLASSO.res,
is.s.hat.nan = is.s.hat.nan.res,
s.hat0=s.hat0.res,
s0.hat0=s0.hat0.res,
s1.hat0=s1.hat0.res,
bmin0.hat0=bmin0.hat0.res,
bmin1.hat0=bmin1.hat0.res
)
if(length(sel.IC)!=0){
df[df$method=='IC','sel.model'] <- sel.IC
}else{
print(sel.IC)
}
if(length(sel.ebic)!=0){
df[df$method=='EBIC','sel.model'] <- sel.ebic
}else{
print(sel.ebic)
}
if(length(sel.lasso)!=0){
df[df$method=='lasso','sel.model'] <- sel.lasso
}else{
print(sel.lasso)
}
if(length(sel.baseline1)!=0){
df[df$method=='baseline1','sel.model'] <- sel.baseline1
}else{
print(sel.baseline1)
}
if(length(sel.baseline2)!=0){
df[df$method=='baseline2','sel.model'] <- sel.baseline2
}else{
print(sel.baseline2)
}
if(length(sel.method1.1)!=0){
df[df$method=='method1.1','sel.model'] <- sel.method1.1
}else{
print(sel.method1.1)
}
if(length(sel.method1.2)!=0){
df[df$method=='method1.2','sel.model'] <- sel.method1.2
}else{
print(sel.method1.2)
}
if(length(sel.method2)!=0){
df[df$method=='method2','sel.model'] <- sel.method2
}else{
print(sel.method2)
}
gc()
return(df)
}
##### Scenario ######
nb.inactive2 <-function(n){
return(n/2)
}
nb.inactive3 <-function(n){
return(n)
}
nb.inactive.tot<-function(n,nb.inactive.b0=nb.inactive3,nb.inactive.b1=nb.inactive2){
nb.inactive.b0(n)+nb.inactive.b1(n)
}
nb.active<- function(n){
return(exp(sqrt(log(n))))
}
# Dimension
bmin <- function(n,fun.nb.inactive){
bmin <- sqrt(8*log(fun.nb.inactive(n=n))/n*(2*log(log(n))/3))
#bmin <- 3
return(bmin)
}
# Generate design matrix
# n <- 700
# p <- 2000
# set.seed(27)
# cov <- 0.5
# Sigma <- matrix(rep(cov,p*p),ncol=p)
# diag(Sigma) <- rep(1,p)
# mu <- rep(0,p)
# X <- rmvnorm(n,mu,Sigma)
# X.design <- X %*% diag(1/sqrt(diag(t(X) %*% X)/n))
# write.csv(X.design,"X.designp2000n700.corr.csv",row.names = FALSE)
#X <- as.matrix(read.csv("X.designp10000.corr.csv"))
X <- as.matrix(read.csv("X.designp2000n700.corr.csv"))
# Generate errors
# epsilon <- rnorm(700*100,0,1)
# write.csv(epsilon,"epsilon.csv",row.names = FALSE)
epsilon <- as.matrix(read.csv("epsilon.csv"))
options(error=browser)
###################################################
values <- seq(200,700,100)
iter <- 1
for (n  in values){
niter <- length(values)
betamin <- bmin(n,nb.inactive.tot)
beta_star0 <- c(rep(betamin,round(nb.active(n)/2)), rep(0,nb.inactive3(n)))
beta_star1 <- c(rep(betamin,round(nb.active(n)/2)), rep(0,nb.inactive2(n)))
beta_star <- c(beta_star0, beta_star1)
block0 <- c(1:length(beta_star0))
block1 <- c((length(beta_star0)+1):(length(beta_star0)+length(beta_star1)))
X.design <- X[1:n,1:length(beta_star)]
# Simulation
m <- 100 #number of simulations
y.df <- replicate(m,(X.design%*%(beta_star))[,1])+epsilon[1:(n*m),1]
t0 <- Sys.time()
sim.result <- future_apply(y.df,2,selection.comp,X.design=X.design, block0=block0, block1=block1, beta_star= beta_star, future.seed=TRUE)
sim.result.df <- bind_rows(sim.result)
# sim.result.df <- data.frame()
# for(i in 1:100){
#   res<- selection.comp(y.df[,i],X.design=X.design, block0=block0, block1=block1, beta_star= beta_star)
#   sim.result.df <- bind_rows(sim.result.df,res)
# }
sim.result.df$betamin <- betamin
sim.result.df['recovery']<-  sim.result.df$sel.model==paste(as.character(which(beta_star!=0)),collapse=",")
sel.list <- lapply(sim.result.df$sel.model, model.char2vec)
sim.result.df['nb.tI.b0'] <- sapply(sel.list, nb.error, true.beta=beta_star, type='I', block=block0)
sim.result.df['nb.tI.b1'] <- sapply(sel.list, nb.error, true.beta=beta_star, type='I', block=block1)
sim.result.df['nb.tII.b0'] <- sapply(sel.list, nb.error, true.beta=beta_star, type='II', block=block0)
sim.result.df['nb.tII.b1'] <- sapply(sel.list, nb.error, true.beta=beta_star, type='II', block=block1)
sim.result.df['est.size'] <- sapply(sel.list,length)
write.csv(sim.result.df,paste0("sim.result.scenario2.n",n,".csv"),row.names = FALSE)
t1 <- Sys.time()
cat('Time iteration',iter,'out of', paste0(niter,':'), round(difftime(t1, t0, units = "mins"),3),'minutes'); cat('\n');
iter <- iter +1
}
knitr::opts_chunk$set(echo = TRUE)
####
res.varn <- data.frame()
for (n  in seq(100,600,100)){
temp<-read.csv(paste0("C:/Users/u200038/Documents/sim11102024/scenario2/sim.result.scenario2.n",n,".csv"))
summary.sim.result <- temp %>% group_by(method) %>%
summarise(prob.recovery = mean(recovery),mean.size.sel =mean(est.size))
summary.sim.result$n <- rep(n, nrow(summary.sim.result))
res.varn<- rbind(res.varn,summary.sim.result)
}
# res.varn[res.varn$method=="IC s hat",'method'] <- "block IC s hat 3 tweaked"
# res.varn[res.varn$method=="block IC s hat 2",'method'] <- "block IC s hat 2 tweaked"
# res.varn[res.varn$method=="block IC s hat",'method'] <- "block IC s hat tweaked"
# res.varn[res.varn$method=="EBIC exact",'method'] <- "EBIC"
# res.varn[res.varn$method=="IC exact",'method'] <- "IC"
res.varn %>%ggplot() + geom_line(aes(x=n, y=prob.recovery, col=method), size=1)
View(res.varn)
####
res.varn <- data.frame()
for (n  in seq(100,700,100)){
temp<-read.csv(paste0("C:/Users/u200038/Documents/sim11102024/scenario2/sim.result.scenario2.n",n,".csv"))
summary.sim.result <- temp %>% group_by(method) %>%
summarise(prob.recovery = mean(recovery),mean.size.sel =mean(est.size))
summary.sim.result$n <- rep(n, nrow(summary.sim.result))
res.varn<- rbind(res.varn,summary.sim.result)
}
# res.varn[res.varn$method=="IC s hat",'method'] <- "block IC s hat 3 tweaked"
# res.varn[res.varn$method=="block IC s hat 2",'method'] <- "block IC s hat 2 tweaked"
# res.varn[res.varn$method=="block IC s hat",'method'] <- "block IC s hat tweaked"
# res.varn[res.varn$method=="EBIC exact",'method'] <- "EBIC"
# res.varn[res.varn$method=="IC exact",'method'] <- "IC"
res.varn %>%ggplot() + geom_line(aes(x=n, y=prob.recovery, col=method), size=1)
setwd("~/sim11102024/scenario4")
knitr::opts_chunk$set(echo = TRUE)
####
res.varn <- data.frame()
for (n  in seq(100,600,100)){
temp<-read.csv(paste0("C:/Users/u200038/Documents/sim11102024/scenario2/sim.result.scenario4.n",n,".csv"))
summary.sim.result <- temp %>% group_by(method) %>%
summarise(prob.recovery = mean(recovery),mean.size.sel =mean(est.size))
summary.sim.result$n <- rep(n, nrow(summary.sim.result))
res.varn<- rbind(res.varn,summary.sim.result)
}
####
res.varn <- data.frame()
for (n  in seq(100,600,100)){
temp<-read.csv(paste0("C:/Users/u200038/Documents/sim11102024/scenario4/sim.result.scenario4.n",n,".csv"))
summary.sim.result <- temp %>% group_by(method) %>%
summarise(prob.recovery = mean(recovery),mean.size.sel =mean(est.size))
summary.sim.result$n <- rep(n, nrow(summary.sim.result))
res.varn<- rbind(res.varn,summary.sim.result)
}
library(tidyverse)
####
res.varn <- data.frame()
for (n  in seq(100,600,100)){
temp<-read.csv(paste0("C:/Users/u200038/Documents/sim11102024/scenario4/sim.result.scenario4.n",n,".csv"))
summary.sim.result <- temp %>% group_by(method) %>%
summarise(prob.recovery = mean(recovery),mean.size.sel =mean(est.size))
summary.sim.result$n <- rep(n, nrow(summary.sim.result))
res.varn<- rbind(res.varn,summary.sim.result)
}
# res.varn[res.varn$method=="IC s hat",'method'] <- "block IC s hat 3 tweaked"
# res.varn[res.varn$method=="block IC s hat 2",'method'] <- "block IC s hat 2 tweaked"
# res.varn[res.varn$method=="block IC s hat",'me
# res.varn[res.varn$method=="EBIC exact",'method'] <- "EBIC"
# res.varn[res.varn$method=="IC exact",'method'] <- "IC"
res.varn %>%ggplot() + geom_line(aes(x=n, y=prob.recovery, col=method), size=1) + coord_cartesian(ylim=c(0,1))
res.varn %>% filter(method %in% c('baseline2', 'IC', 'method2')) %>%ggplot() + geom_line(aes(x=n, y=prob.recovery, col=method), size=1) + coord_cartesian(ylim=c(0,1))
res.varn %>% filter(method %in% c('baseline1', 'EBIC', 'method1.1', 'method1.2')) %>%ggplot() + geom_line(aes(x=n, y=prob.recovery, col=method), size=1) + coord_cartesian(ylim=c(0,1))
